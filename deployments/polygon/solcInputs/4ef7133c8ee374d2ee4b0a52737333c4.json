{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/IOwnable.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IOwnable {\n  /**\n   * @dev Returns the address of the current owner.\n   */\n  function owner() external view returns (address);\n\n  /**\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\n   * Can only be called by the current owner.\n   */\n  function transferOwnership(address newOwner) external;\n}\n"
    },
    "contracts/interfaces/ITokenPriceFeed.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./IOwnable.sol\";\n\ninterface ITokenPriceFeed is IOwnable {\n    struct TokenInfo {\n        address priceFeed;\n        uint256 mcr; // Minimum Collateralization Ratio\n        uint256 mlr; // Minimum Liquidation Ratio\n        uint256 borrowRate;\n        uint256 decimals;\n    }\n\n    function tokenPriceFeed(address) external view returns (address);\n\n    function tokenPrice(address _token) external view returns (uint256);\n\n    function mcr(address _token) external view returns (uint256);\n\n    function decimals(address _token) external view returns (uint256);\n\n    function mlr(address _token) external view returns (uint256);\n\n    function borrowRate(address _token) external view returns (uint256);\n\n    function setTokenPriceFeed(address _token, address _priceFeed, uint256 _mcr, uint256 _mlr, uint256 _borrowRate, uint256 _decimals) external;\n\n    event NewTokenPriceFeed(\n        address _token,\n        address _priceFeed,\n        string _name,\n        string _symbol,\n        uint256 _mcr,\n        uint256 _mlr,\n        uint256 _borrowRate,\n        uint256 _decimals\n    );\n}\n"
    },
    "contracts/interfaces/IVault.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IVault {\n    function vaultOwner() external view returns (address);\n    function debt() external view returns (uint256);\n    function transferVaultOwnership(address _newOwner) external;\n    function setName(string memory _name) external;\n    function containsCollateral(address _collateral) external view returns (bool);\n    function collateralsLength() external view returns (uint256);\n    function collateralAt(uint256 _index) external view returns (address);\n    function collaterals() external view returns (address[] memory);\n    function collateral(address _collateral) external view returns (uint256);\n    function factory() external view returns (address);\n    function addCollateral(address _collateral, uint256 _amount) external;\n    function removeCollateral(address _collateral, uint256 _amount, address _to) external;\n    function addBadDebt(uint256 _amount) external;\n    function borrowable() external view returns (uint256 _maxBorrowable, uint256 _borrowable);\n    function borrow(uint256 _amount) external;\n    function repay(uint256 _amount) external;\n    function calcRedeem(\n        address _collateral,\n        uint256 _collateralAmount\n    ) external view returns (uint256 _stableAmountNeeded, uint256 _redemptionFee);\n    function redeem(\n        address _collateral,\n        uint256 _collateralAmount\n    ) external returns (uint256 _debtRepaid, uint256 _feeCollected);\n    function healthFactor(bool _useMlr) external view returns (uint256 _healthFactor);\n    function newHealthFactor(uint256 _newDebt, bool _useMlr) external view returns (uint256 _newHealthFactor);\n    function borrowableWithDiff(\n        address _collateral,\n        uint256 _diffAmount,\n        bool _isAdd,\n        bool _useMlr\n    ) external view returns (uint256 _maxBorrowable, uint256 _borrowable);\n    function liquidate() external returns (uint256 _forgivenDebt);\n}\n"
    },
    "contracts/interfaces/IVaultFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.4;\n\ninterface IVaultFactory {\n    event NewVault(address indexed vault, string name, address indexed owner);\n    event PriceFeedUpdated(address indexed priceFeed);\n\n    function setPriceFeed(address _priceFeed) external;\n    function vaultCount() external view returns (uint256);\n    function lastVault() external view returns (address);\n    function firstVault() external view returns (address);\n    function nextVault(address _vault) external view returns (address);\n    function prevVault(address _vault) external view returns (address);\n    function liquidationRouter() external view returns (address);\n    function MAX_TOKENS_PER_VAULT() external view returns (uint256);\n    function priceFeed() external view returns (address);\n    function transferVaultOwnership(address _vault, address _newOwner) external;\n    function createVault(string memory _name) external returns (address);\n    function addCollateralNative(address _vault) external payable;\n    function removeCollateralNative(address _vault, uint256 _amount, address _to) external;\n    function addCollateral(address _vault, address _collateral, uint256 _amount) external;\n    function removeCollateral(address _vault, address _collateral, uint256 _amount, address _to) external;\n    function borrow(address _vault, uint256 _amount, address _to) external;\n    function distributeBadDebt(address _vault, uint256 _amount) external;\n    function closeVault(address _vault) external;\n    function repay(address _vault, uint256 _amount) external;\n    function redeem(address _vault, address _collateral, uint256 _collateralAmount, address _to) external;\n    function liquidate(address _vault) external;\n    function isLiquidatable(address _vault) external view returns (bool);\n    function isReedemable(address _vault, address _collateral) external view returns (bool);\n    function containsVault(address _vault) external view returns (bool);\n    function stable() external view returns (address);\n    function isCollateralSupported(address _collateral) external view returns (bool);\n    function vaultsByOwnerLength(address _owner) external view returns (uint256);\n    function redemptionHealthFactorLimit() external view returns (uint256);\n}\n\n"
    },
    "contracts/VaultFactoryHelper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.4;\n\nimport \"./interfaces/IVaultFactory.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/ITokenPriceFeed.sol\";\n\ncontract VaultFactoryHelper {\n    uint256 public constant DECIMAL_PRECISION = 1e18;\n\n    function getAllVaults(address _vaultFactory) public view returns (address[] memory) {\n        IVaultFactory vaultFactory = IVaultFactory(_vaultFactory);\n        uint256 vaultCount = vaultFactory.vaultCount();\n        if (vaultCount == 0) {\n            return new address[](0);\n        } else {\n            address[] memory vaults = new address[](vaultCount);\n            vaults[0] = vaultFactory.firstVault();\n            for (uint256 i = 1; i < vaultCount; i++) {\n                vaults[i] = vaultFactory.nextVault(vaults[i - 1]);\n            }\n            return vaults;\n        }\n    }\n\n    function getVaultTvlByCollateral(address _vaultAddress, address _collateralAddress) public view returns (uint256) {\n        IVault _vault = IVault(_vaultAddress);\n        uint256 _collateralAmount = _vault.collateral(_collateralAddress);\n        ITokenPriceFeed _priceFeed = ITokenPriceFeed(IVaultFactory(_vault.factory()).priceFeed());\n        uint256 _price = _priceFeed.tokenPrice(_collateralAddress);\n        uint256 _normalizedCollateralAmount = _collateralAmount * (10 ** (18 - _priceFeed.decimals(_collateralAddress)));\n        uint256 _tvl = (_normalizedCollateralAmount * _price) / DECIMAL_PRECISION;\n        return _tvl;\n    }\n\n    function getVaultTvl(address _vault) public view returns (uint256) {\n        IVault vault = IVault(_vault);\n        uint256 tvl = 0;\n        for (uint256 i = 0; i < vault.collateralsLength(); i++) {\n            address _collateralAddress = vault.collateralAt(i);\n            tvl += getVaultTvlByCollateral(_vault, _collateralAddress);\n        }\n        return tvl;\n    }\n\n    function getLiquidatableVaults(address _vaultFactory) public view returns (address[] memory) {\n        IVaultFactory vaultFactory = IVaultFactory(_vaultFactory);\n        uint256 vaultCount = vaultFactory.vaultCount();\n        uint256 liquidatableVaultCount = 0;\n        if (vaultCount == 0) {\n            return new address[](0);\n        } else {\n            address[] memory _vaults = getAllVaults(_vaultFactory);\n            address[] memory _liquidatableVaults = new address[](vaultCount);\n\n            for (uint256 i = 0; i < vaultCount; i++) {\n                IVault _vault = IVault(_vaults[i]);\n                if (vaultFactory.isLiquidatable(address(_vault))) {\n                    _liquidatableVaults[liquidatableVaultCount] = address(_vault);\n                    liquidatableVaultCount++;\n                }\n            }\n\n            address[] memory liquidatableVaults = new address[](liquidatableVaultCount);\n            for (uint256 i = 0; i < liquidatableVaultCount; i++) {\n                liquidatableVaults[i] = _liquidatableVaults[i];\n            }\n\n            return liquidatableVaults;\n        }\n    }\n\n    function getRedeemableVaults(address _vaultFactory, bool _useMlr) public view returns (address[] memory redeemableVaults, address[] memory redeemableCollaterals) {\n\n        IVaultFactory vaultFactory = IVaultFactory(_vaultFactory);\n        uint256 vaultCount = vaultFactory.vaultCount();\n        uint256 redeemableVaultCount = 0;\n        uint256 healthFactorLimit = vaultFactory.redemptionHealthFactorLimit();\n        if (vaultCount == 0) {\n            return (new address[](0), new address[](0));\n        } else {\n            address[] memory _vaults = getAllVaults(_vaultFactory);\n            address[] memory _redeemableVaults = new address[](vaultCount);\n            address[] memory _redeemableCollaterals = new address[](vaultCount);\n\n            for (uint256 i = 0; i < vaultCount; i++) {\n                IVault _vault = IVault(_vaults[i]);\n                if (_vault.healthFactor(_useMlr) < healthFactorLimit) {\n                    _redeemableVaults[redeemableVaultCount] = address(_vault);\n\n                    address[] memory _collaterals = getVaultCollaterals(address(_vault));\n\n                    for (uint256 j = 0; j < _collaterals.length; j++) {\n                        if (vaultFactory.isReedemable(address(_vault), _collaterals[j])) {\n                            _redeemableCollaterals[redeemableVaultCount] = _collaterals[j];\n                            break;\n                        }\n                    }\n\n                    redeemableVaultCount++;\n                }\n            }\n\n            redeemableVaults = new address[](redeemableVaultCount);\n            redeemableCollaterals = new address[](redeemableVaultCount);\n\n            for (uint256 i = 0; i < redeemableVaultCount; i++) {\n                redeemableVaults[i] = _redeemableVaults[i];\n                redeemableCollaterals[i] = _redeemableCollaterals[i];\n            }\n        }\n\n    }\n\n    function getVaultCollaterals(address _vault) public view returns (address[] memory) {\n        IVault vault = IVault(_vault);\n        uint256 collateralsLength = vault.collateralsLength();\n        if (collateralsLength == 0) {\n            return new address[](0);\n        } else {\n            address[] memory collaterals = new address[](collateralsLength);\n            for (uint256 i = 0; i < collateralsLength; i++) {\n                collaterals[i] = vault.collateralAt(i);\n            }\n            return collaterals;\n        }\n    }\n\n    function getProtocolTvl(address _vaultFactory) public view returns (uint256) {\n        IVaultFactory vaultFactory = IVaultFactory(_vaultFactory);\n        uint256 vaultCount = vaultFactory.vaultCount();\n        uint256 tvl = 0;\n        if (vaultCount == 0) {\n            return 0;\n        } else {\n            address[] memory _vaults = getAllVaults(_vaultFactory);\n            for (uint256 i = 0; i < vaultCount; i++) {\n                tvl += getVaultTvl(_vaults[i]);\n            }\n            return tvl;\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}